### Compose 状态



#### 1、状态的定义：

##### 	1、在科学技术中，值物质系统所处的状况。也指各种聚集态，如物质的固、液、气、等态

##### 	2、当系统的温度、压力、体积、物态、物质的量、各种能量等等一定时，我们就说系统处于一个状态（state）



#### 2、应用中的状态

##### 	1、应用中的状态是指可以随变化的任何值，这是一个非常宽泛的定义，从Room数据库到类的变量，全部涵盖在内

##### 	2、所有Android应用都会向用户显示状态。下面是Android应用中的一些状态示例

###### 		1、在无法建立网络连接时显示的信息提示控件

###### 		2、博文和相关评论

###### 		3、在用户点击按钮时播放的波纹动画

###### 		4、用户可以在图片上绘制的贴纸



#### 3、UI更新循环（非结构化状态）

##### 	1、是什么导致状态更新？在Android应用程序中，状态会根据事件进行更新。事件是从我们的应用程序外部生成的输入，例如用户点击按钮

###### 		1、事件：事件由用户或程序的其他部分生成

###### 		2、更新状态：事件处理程序更改UI使用的状态

###### 		3、显示状态：更新UI以显示新状态



### 非结构化状态：

​	在我们开始Compose之前，我们探索Android试图系统中的事件和状态。

![image-20220928084825587](C:\Users\Ywhuii\Documents\Jetpack Compose\代码图片示例\image-20220928084825587.png)

​	

#### 	1、当我们添加更多事件和状态时，可能会出现几个问题：

###### 		1、测试：由于UI的状态与Views代码交织在一起，因此很难测试此代码

###### 		2、部分状态更新：当屏幕有更多事件时，很容易忘记更新部分状态以响应事件。因此，用户可能会看到不一致或不正确的UI

###### 		3、部分UI更新：由于我们在每次状态更改后手动更新UI，因此有时很容易忘记这一点。因此，用户可能会在其UI中看到随机更新的陈旧数据

###### 		4、代码复杂性：在这种模式下编码时很难提取一些逻辑。结果，代码有变得难以阅读和理解的趋势

​	

### 单向数据流

​	为了帮助解决非结构化状态的这些问题，我们引入了ViewModel和LiveData

​	我们将状态从Activity移到了ViewModel，在ViewModel中，状态由LiveData表示。LiveData是一种可观察状态容器，这意味着它可让任何人观察状态的变化。然后，我们在界面中使用observe方法，以便在状态变化时更新界面

![image-20220928084804882](C:\Users\Ywhuii\Documents\Jetpack Compose\代码图片示例\image-20220928084804882.png)



#### 	1、我们可以看到此ViewModel是如何与事件和状态配合工作的：

###### 		1、事件：onNameChanged当文本输入更改时由UI调用

###### 		2、更新状态：进行onNameChanged处理，然后设置状态_name

###### 		3、显示状态：name的观察者被调用，通知UI状态变化

###### 		通过以这种方式构建代码，我们可以将事件"向上"流动到ViewModel。然后，为了响应事件，ViewModel将进行一些处理，而且可能会更新状态。状态更新后，会"向下"流动到Activity



#### 	2、单向数据流是一种状态向下流动而事件向上流动的设计，它的优势有：

###### 		1、可测试性：通过将状态与显示它的UI分离，可以更轻松地测试ViewModel和Activity

###### 		2、状态封装：因为状态只能在一个地方（the ViewModel）更新，随着UI的增长，你不太可能引入部分状态更新错误

###### 		3、UI一致性：所有状态更新都通过使用可观察状态持有者立即反映在UI中



#### 	3、状态提升	代码见JetpackComposeState Todo.one包

###### 		1、如果可组合项是无状态的，那它如何才能显示可修改的列表？为实现此目的，我们会使用一种称为状态提升的技术

###### 		2、Compose中的状态提升是一种将状态移至可组合项的调用方以使可组合项无状态的模式。无状态组件更容易测试，往往有更少的错误，并提供更多的重用机会

###### 		3、事实证明，这些参数的组合使得调用方法能够从此可组合项中提升状态。为了了解具体的工作原理，我们来探索此可组合项的界面更新循环。

​				事件：当用户请求添加或删除项时，TodoScreen会调用onAddItem或onRemoveItem

​				更新状态：TodoScreen的调用方可以通过更新状态来响应这些事件

​				显示状态：状态更新后，系统将使用新的items再次调用TodoScreen，而且后者可以在界面上显示它们

###### 		4、调用方负责确定保持此状态的位置和方式。不过，它可以合理地存储items，例如，存储在内存中或从Room数据库中读取。TodoScreen与状态的管理方式是完全解耦的

###### 		5、当应用于可组合项时，这通常意味着向可组合项引入两个参数

​				value:T	要显示的当前值

​				onValueChange:(T) -> Unit	请求更改值的事件，其中T是建议的新值

​	

#### 	4、组件树

​		Compose为TodoScreen生成的组件树



#### 	5、重组

​		在命令式界面模型中，如需要更改某个组件，您可以在该组件上调用Setter以更改其内部状态。在Compose中，您可以使用新数据再次调用可组合函数。这样做会导致函数进行重组——系统会根据需要使用新数据重新绘制函数发出的组件。Compose框架可以智能地仅重组已更改的组件

##### 		解决：将内存引入可组合函数

###### 			1、remember提供了可组合函数内存

###### 			2、系统会将由remember计算的值存储在组合树中，而且只有当remember的键发生变化时才会重新计算该值

###### 			3、可以将remember看作是为函数提供单个对象的存储空间，过程与private val 属性在对象中执行的操作相同

![image-20220928114552688](C:\Users\Ywhuii\Documents\Jetpack Compose\代码图片示例\image-20220928114552688.png)

​		

#### 	6、有状态与无状态

###### 			1、使用remember存储对象的可组合项会创建内部状态，使该组合项有状态。

###### 			2、在调用方不需要控制状态，并且不必自行管理状态便可使用状态的情况下，"有状态"会非常有用。但是，具有内部状态的可组合项往往不易重复使用，也更难测试

###### 			3、无状态可组合项是指不保持任何状态的可组合项。实现无状态的一种简单方法是使用状态提升



#### 	展开折叠UI部分：



#### 	7、MutableState

###### 	1、此函数使用remember向自身添加内存，然后在内存中存储mutableStateOf，以创建MutableState<String>，这是一种提供可观察状态容器的内置Compose类型

###### 	2、对value进行的任何更改都会自动重组用于读取此状态的所有可组合函数